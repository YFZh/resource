Linux的终端与进程
2011-04-20 17:00 佚名 Linux社区 字号：T | T
一键收藏，随时查看，分享好友！
本篇文章为读者详细解释了Linux系统下终端与进程的含义，并通过代码与截图来帮助大家进行理解，个人觉得对于初学者来说会有很大的帮助！
AD：51CTO 网+ 第十二期沙龙：大话数据之美_如何用数据驱动用户体验
Linux的普通进程(守护进程除外) 是终端的子进程，进程的存在要依赖终端为其提供空间包括标准输入、标准输出、标准出错。比如，在ssh的客户端启动一个连入linux的终端，运行pstree命令，可以看到如下结果：



可以看到pstree相当于当前终端启动的一个子进程。

然后，我们在输入sleep 2000 &命令，让终端启动一个在后台运行的sleep进程，接下来再运行pstreee；



可以看到，启动了一个pid为1354的进程，然后该进程的父进程为sshd，也就是ssh服务启动的终端；

然后，在/proc/1354/fd下，可以看到如下内容：



其中的0、1、2分别指标准输入、标准输出和标准出错，并且它们都指向了/dev/pts/0；

这里的pts是指：pseudo-terminal slave，是虚拟终端的一种实现方式，0是虚拟终端的编号。可以输入ll /dev/pts/看一下结果：



从中可以看出在/dev/pts目录下，一共有3个虚拟终端正在运行。

现在回到虚拟机上的终端界面，也就是X系统上的终端，也在后台运行一个sleep，再进到这个进程所对应的fd目录下，可以看到如下结果：

结果图

这里的标准输入、标准输出和标准出错指向了/dev/tty1，tty是真正的终端，pts则是对它的虚拟。

在进程运行过程中（即使是后台运行的进程），当终端退出时，进程将会收到SIGHUP信号，如果程序没有对这种信号进行捕获处理，进程默认就会退出。还以刚才那个在虚拟终端中后台运行的sleep为例：



这是，sleep正在运行是的情况，当我把它的终端关闭后，情况为：



bash少了一个，并且sleep没有了。

因为关闭了一个ssh的虚拟终端，自然会少一个bash，同时在作为该终端子进程的sleep也同时退出了。

那如何让一个程序在终端退出后继续工作呢？

首先一个明确的思路是，可以将要启动的进程的父进程设为init，这样不过当前的终端怎么样，都不会影响进程的运行。可以这样：

setuid ping localhost > /dev/null &
或者

( ping localhost > /dev/null &)


可以看出，ping直接成为init的子进程了。

另外，也可以用nohup命令来实现。